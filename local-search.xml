<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>二叉堆</title>
    <link href="/2025/09/06/%E4%BA%8C%E5%8F%89%E5%A0%86/"/>
    <url>/2025/09/06/%E4%BA%8C%E5%8F%89%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h1><h2 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h2><p>定义：它是一棵二叉树, 并且是完全二叉树。</p><p>堆性质：父亲的权值不小于儿子的权值</p><p>存储：首先我们用一个数组h来表示堆, 对于每个h[i], 它的儿子是h[i * 2]和h[i * 2 + 1], 下面有一张很形象的图。</p><p><img src="https://oi-wiki.org/ds/images/binary-heap-array.svg" alt="二叉堆"></p><h2 id="二叉堆的两个基本操作"><a href="#二叉堆的两个基本操作" class="headerlink" title="二叉堆的两个基本操作"></a>二叉堆的两个基本操作</h2><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><p>操作：在堆的最下一层最右边的叶子之后插入一个元素, 如果最下一层已满, 就新增一层。(一直满足满二叉树的性质)</p><p>疑问：如果插入以后不满足堆的性质怎么办？</p><p>所以，我们要 <strong>向上调整</strong> , 如果插进来的新节点, 每大于它的父亲节点，便交换一次位置, 直到不满足或作为根节点为止。</p><p><img src="https://oi-wiki.org/ds/images/binary_heap_insert.svg" alt="插入操作"></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
